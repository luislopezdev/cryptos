<!DOCTYPE html>
<html lang="es" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crypto Tracker</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Estilos generales y modo oscuro (sin cambios) */
        body { font-family: 'Inter', sans-serif; -webkit-tap-highlight-color: transparent; }
        :root {
            --bg-dark: #1e2329; --card-dark: #2b3139; --text-primary-dark: #e5e7eb;
            --text-secondary-dark: #9ca3af; --positive-bg: #16c784; --negative-bg: #ea3943;
            --positive-text: #ffffff; --negative-text: #ffffff; --border-dark: #4b5563;
        }
        body.dark { background-color: var(--bg-dark); color: var(--text-primary-dark); }
        .dark #crypto-container { background-color: var(--card-dark); border-color: var(--border-dark); }
        .dark .crypto-card { background-color: var(--card-dark); border-color: var(--border-dark); position: relative; }
        .dark .crypto-card:hover { background-color: #374151; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.2), 0 2px 4px -1px rgba(0, 0, 0, 0.12); }
        .dark .loader { border-color: var(--border-dark); border-top-color: #60a5fa; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .modal { transition: opacity 0.25s ease; }
        .modal-content { transition: transform 0.25s ease, width 0.3s ease, height 0.3s ease, max-width 0.3s ease; }
        body.modal-active { overflow: hidden; }
        .price-up { animation: flash-green-subtle 0.7s ease-out; }
        .price-down { animation: flash-red-subtle 0.7s ease-out; }
        @keyframes flash-green-subtle { 0%, 100% { color: inherit; } 50% { color: var(--positive-bg); } }
        @keyframes flash-red-subtle { 0%, 100% { color: inherit; } 50% { color: var(--negative-bg); } }
        #tradingview-iframe-container iframe { display: block; width: 100%; height: 100%; }
        #tradingview-iframe-container { min-height: 320px; }
        @media (min-width: 768px) { #tradingview-iframe-container { min-height: 384px; } }
        .modal.fullscreen .modal-content { width: 90vw; max-width: 1600px; }
        .crypto-card {
            transition: transform 0.3s ease-in-out, box-shadow 0.2s ease-in-out, opacity 0.2s ease-in-out;
            cursor: grab; user-select: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none;
        }
        .crypto-card:hover:not(.dragging) { transform: translateY(-4px); } /* Aplicar hover solo si no se arrastra */
        .dark .crypto-card.dragging:hover { box-shadow: none; }
        .change-badge { display: inline-block; padding: 2px 8px; border-radius: 4px; font-weight: 600; font-size: 0.875rem; text-align: center; min-width: 70px; }
        .change-badge.positive { background-color: var(--positive-bg); color: var(--positive-text); }
        .change-badge.negative { background-color: var(--negative-bg); color: var(--negative-text); }
        .change-badge.neutral { background-color: var(--border-dark); color: var(--text-secondary-dark); }

        /* Estilos Drag and Drop */
        .crypto-card.dragging {
            opacity: 0.4;
            cursor: grabbing;
            border: 2px dashed var(--text-secondary-dark);
            transition: opacity 0.2s ease-in-out; /* Solo transicionar opacidad */
        }
         /* Estilo para indicar sobre qué elemento se soltaría */
        .drag-over-target {
             /* Ejemplo: un borde sutil o cambio de fondo */
             /* outline: 2px dashed var(--positive-bg); */
             /* outline-offset: -2px; */
             background-color: rgba(255, 255, 255, 0.05); /* Ligero cambio de fondo */
        }
        body.dragging-active { overflow: hidden; }
        .remove-crypto-btn { position: absolute; top: 4px; right: 4px; background-color: rgba(0, 0, 0, 0.3); border-radius: 50%; padding: 2px; line-height: 1; opacity: 0.5; transition: opacity 0.2s ease; }
        .crypto-card:hover .remove-crypto-btn { opacity: 1; }
        .remove-crypto-btn:hover { background-color: rgba(234, 57, 67, 0.8); }
        .button-loader > div { display: inline-block; }

    </style>
     <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/lucide-static@latest/dist/lucide.min.js"></script>
</head>
<body class="dark">

    <div class="container mx-auto p-4 sm:p-6 md:p-8 max-w-7xl">
        <header class="mb-6 text-center">

        </header>

        <div class="mb-6 flex justify-end">
            <button id="add-crypto-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-lg shadow flex items-center space-x-2">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-plus"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>
                <span>Añadir Crypto</span>
            </button>
        </div>

        <div id="crypto-container" class="bg-gray-800/50 rounded-xl shadow-lg overflow-hidden border border-gray-700">
            <div class="p-5 md:p-8">
                <div id="loading" class="text-center py-10">
                    <div class="loader"></div>
                    <p class="text-gray-400 mt-3">Cargando datos iniciales...</p>
                </div>
                <div id="error-message" class="hidden text-center text-red-400 bg-red-900/30 p-4 rounded-lg border border-red-700">
                    </div>
                <div id="crypto-grid-container" class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-4 md:gap-6">
                     </div>
            </div>
        </div>

    </div>

    <div id="chart-modal" class="modal pointer-events-none fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-80 opacity-0">
       <div class="modal-content bg-gray-900 rounded-lg shadow-xl w-11/12 p-4 md:p-6 transform scale-95 flex flex-col border border-gray-700">
            <div class="flex justify-between items-center border-b border-gray-700 pb-3 mb-4 flex-shrink-0">
                <h3 id="chart-modal-title" class="text-xl font-semibold text-gray-100">Gráfico de Precios</h3>
                <div class="flex items-center space-x-2">
                    <button id="fullscreen-btn" title="Expandir" class="p-1 text-gray-400 hover:bg-gray-700 rounded">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-maximize"><path d="M8 3H5a2 2 0 0 0-2 2v3"/><path d="M21 8V5a2 2 0 0 0-2-2h-3"/><path d="M3 16v3a2 2 0 0 0 2 2h3"/><path d="M16 21h3a2 2 0 0 0 2-2v-3"/></svg>
                    </button>
                    <button id="close-modal-btn" title="Cerrar" class="p-1 text-gray-400 hover:bg-gray-700 rounded text-2xl">&times;</button>
                </div>
            </div>
            <div id="tradingview-iframe-container-wrapper" class="relative w-full flex-grow h-80 md:h-[450px] bg-gray-900">
                 <div id="chart-loader" class="absolute inset-0 flex items-center justify-center bg-gray-900 bg-opacity-75 z-10">
                    <div class="loader"></div>
                 </div>
                 <div id="chart-error" class="absolute inset-0 flex items-center justify-center bg-gray-900 z-10 hidden text-red-400 p-4 text-center"></div>
                 <div id="tradingview-iframe-container" class="w-full h-full"></div>
            </div>
        </div>
    </div>

    <div id="add-crypto-modal" class="modal pointer-events-none fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-70 opacity-0">
        <div class="modal-content bg-gray-800 rounded-lg shadow-xl w-11/12 max-w-sm p-6 transform scale-95 border border-gray-700">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-lg font-semibold text-gray-100">Añadir Criptomoneda</h3>
                <button id="close-add-modal-btn" class="text-gray-400 hover:text-white">&times;</button>
            </div>
            <div>
                <label for="crypto-symbol-input" class="block mb-2 text-sm font-medium text-gray-300">Símbolo (ej: PEPEUSDT)</label>
                <input type="text" id="crypto-symbol-input" class="bg-gray-700 border border-gray-600 text-gray-100 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-2.5 uppercase" placeholder="BTCUSDT" required>
                <p id="add-crypto-error" class="text-red-400 text-xs mt-1 h-4"></p>
            </div>
            <div class="mt-4 flex justify-end">
                 <button id="confirm-add-crypto-btn" class="relative bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-lg shadow flex items-center justify-center disabled:opacity-50 disabled:cursor-not-allowed" style="min-width: 80px;">
                    <span class="button-text">Añadir</span>
                    <div class="button-loader hidden absolute inset-0 flex items-center justify-center">
                       <div class="w-4 h-4 border-2 border-white border-t-transparent rounded-full animate-spin"></div>
                    </div>
                 </button>
            </div>
        </div>
    </div>


    <script>
        // URLs API y WebSocket
        const tickerApiUrl = 'https://api.binance.com/api/v3/ticker/24hr';
        const websocketUrl = 'wss://stream.binance.com:9443/ws';

        // Símbolos por defecto
        const defaultCryptos = [
            'BTCUSDT', 'ETHUSDT', 'BNBUSDT', 'SOLUSDT', 'XRPUSDT', 'ADAUSDT',
            'DOGEUSDT', 'SHIBUSDT', 'AVAXUSDT', 'DOTUSDT', 'LINKUSDT', 'TONUSDT',
            'TRXUSDT', 'WLDUSDT', 'LTCUSDT'
        ];

        // Elementos del DOM
        let cryptoGridContainer, loadingIndicator, errorMessage, chartModal, chartModalTitle,
            closeModalBtn, fullscreenBtn, iframeContainer, chartLoader, chartError,
            addCryptoBtn, addCryptoModal, closeAddModalBtn, cryptoSymbolInput,
            confirmAddCryptoBtn, addCryptoErrorMsg;

        let cryptoDataMap = new Map();
        let webSocket = null;
        let draggedElement = null;
        let isDragging = false;
        let dragOverTarget = null; // Elemento sobre el que se soltaría

        // --- Funciones de Persistencia (localStorage) ---
        function getUserCryptos() { /* ... (sin cambios) ... */
            const stored = localStorage.getItem('userCryptoList');
            if (stored) {
                try {
                    const parsed = JSON.parse(stored);
                    if (Array.isArray(parsed) && parsed.every(item => typeof item === 'string')) { return parsed; }
                } catch (e) { console.error("Error parsing user crypto list from localStorage:", e); }
            }
            return [...defaultCryptos];
        }
        function saveUserCryptos(cryptoList) { /* ... (sin cambios) ... */
             try {
                 localStorage.setItem('userCryptoList', JSON.stringify(cryptoList));
                 console.log("Saved validated crypto list to localStorage:", cryptoList);
             } catch (e) { console.error("Error saving user crypto list to localStorage:", e); }
        }

        // --- Funciones de Formato ---
        function formatCurrency(number) { /* ... */
            const num = parseFloat(number);
            if (isNaN(num)) { return '<span class="text-gray-500">N/A</span>'; }
            if (num > 1_000_000_000) { return `$${(num / 1_000_000_000).toFixed(2)}B`; }
            if (num > 1_000_000) { return `$${(num / 1_000_000).toFixed(2)}M`; }
            return num.toLocaleString('en-US', { style: 'currency', currency: 'USD', minimumFractionDigits: num > 1 ? 2 : (num > 0.0001 ? 4 : 6), maximumFractionDigits: num > 1 ? 4 : 6 });
        }
        function formatPercentage(percent) { /* ... */
             const num = parseFloat(percent);
             if (isNaN(num)) { return 'N/A'; }
             const sign = num >= 0 ? '+' : '';
             return `${sign}${num.toFixed(2)}%`;
        }

        // --- Funciones del Modal (Gráfico) ---
        function openModal() { /* ... */
             chartModal.classList.remove('opacity-0', 'pointer-events-none');
             chartModal.querySelector('.modal-content').classList.remove('scale-95');
             document.body.classList.add('modal-active');
             chartModal.classList.remove('fullscreen');
             updateFullscreenButton(false);
        }
        function closeModal() { /* ... */
            chartModal.classList.add('opacity-0');
            chartModal.querySelector('.modal-content').classList.add('scale-95');
            setTimeout(() => {
                chartModal.classList.add('pointer-events-none');
                if (!addCryptoModal || addCryptoModal.classList.contains('pointer-events-none')) {
                    document.body.classList.remove('modal-active');
                }
                if (iframeContainer) { iframeContainer.innerHTML = ''; }
                chartLoader.style.display = 'none';
                chartError.style.display = 'none';
                chartError.textContent = '';
                chartModal.classList.remove('fullscreen');
            }, 250);
        }
        function toggleFullscreen() { /* ... */
            const isFullscreen = chartModal.classList.toggle('fullscreen');
            updateFullscreenButton(isFullscreen);
        }
        function updateFullscreenButton(isFullscreen) { /* ... */
            if (!fullscreenBtn) return;
            if (isFullscreen) {
                fullscreenBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-minimize"><path d="M8 3v3a2 2 0 0 1-2 2H3"/><path d="M21 8h-3a2 2 0 0 1-2-2V3"/><path d="M3 16h3a2 2 0 0 1 2 2v3"/><path d="M16 21v-3a2 2 0 0 1 2-2h3"/></svg>`;
                fullscreenBtn.setAttribute('title', 'Restaurar tamaño');
            } else {
                fullscreenBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-maximize"><path d="M8 3H5a2 2 0 0 0-2 2v3"/><path d="M21 8V5a2 2 0 0 0-2-2h-3"/><path d="M3 16v3a2 2 0 0 0 2 2h3"/><path d="M16 21h3a2 2 0 0 0 2-2v-3"/></svg>`;
                fullscreenBtn.setAttribute('title', 'Expandir');
            }
        }

        // --- Función para mostrar Gráfico con Iframe ---
        function displayChart(symbol) { /* ... (sin cambios) ... */
            console.log(`Displaying TradingView Iframe for ${symbol}`);
            chartModalTitle.textContent = `Gráfico de ${symbol.replace('USDT', '')}/USDT`;
            chartLoader.style.display = 'flex';
            chartError.style.display = 'none';
            chartError.textContent = '';
            if (iframeContainer) { iframeContainer.innerHTML = ''; }
            else { console.error("Iframe container not found!"); chartLoader.style.display = 'none'; chartError.textContent = 'Error interno: No se encontró el contenedor del gráfico.'; chartError.style.display = 'flex'; openModal(); return; }
            openModal();
            try {
                const tradingViewSymbol = `BINANCE:${symbol}`;
                const encodedSymbol = encodeURIComponent(tradingViewSymbol);
                const currentTheme = 'dark';
                const iframeSrc = `https://s.tradingview.com/widgetembed/?frameborder=0&symbol=${encodedSymbol}&interval=D&theme=${currentTheme}&style=3&locale=es&hide_side_toolbar=1&autosize=1`;
                console.log("Creating iframe with src:", iframeSrc);
                const iframe = document.createElement('iframe');
                iframe.setAttribute('src', iframeSrc);
                iframe.setAttribute('style', 'width: 100%; height: 100%; border: 0;');
                iframe.setAttribute('frameborder', '0');
                iframe.setAttribute('allowtransparency', 'true');
                iframe.setAttribute('scrolling', 'no');
                iframe.dataset.symbol = symbol;
                iframe.onload = () => {
                    console.log(`Iframe for ${symbol} loaded (structure).`);
                    setTimeout(() => { if (chartError.style.display === 'none') { chartLoader.style.display = 'none'; } }, 500);
                };
                iframe.onerror = () => {
                     console.error(`Failed to load iframe for ${symbol}`);
                     chartLoader.style.display = 'none';
                     chartError.textContent = `Error al cargar el marco del gráfico para ${symbol}.`;
                     chartError.style.display = 'flex';
                };
                iframeContainer.appendChild(iframe);
            } catch (error) {
                 console.error(`Error creating iframe for ${symbol}:`, error);
                 chartLoader.style.display = 'none';
                 chartError.textContent = `Error al preparar el gráfico para ${symbol}: ${error.message || 'Error desconocido'}`;
                 chartError.style.display = 'flex';
                 if (iframeContainer) iframeContainer.innerHTML = '';
            }
        }

        // --- Funciones de Actualización de Tarjetas (WebSocket) ---
        function updateCardElement(element, newValue, isPriceChange = false, priceGoesUp = false) { /* ... */
            if (element) {
                element.innerHTML = newValue;
                if (isPriceChange && element.classList.contains('crypto-card-price')) {
                    element.classList.remove('price-up', 'price-down');
                    void element.offsetWidth;
                    element.classList.add(priceGoesUp ? 'price-up' : 'price-down');
                }
            }
        }
        function updateChangeBadge(badgeElement, percentValue) { /* ... */
              if (badgeElement) {
                 const num = parseFloat(percentValue);
                 const text = formatPercentage(percentValue);
                 badgeElement.textContent = text;
                 badgeElement.classList.remove('positive', 'negative', 'neutral');
                 if (isNaN(num)) { badgeElement.classList.add('neutral'); }
                 else if (num >= 0) { badgeElement.classList.add('positive'); }
                 else { badgeElement.classList.add('negative'); }
             }
        }

        // --- Funciones WebSocket ---
        function subscribeToTickers(ws, symbols) { /* ... (sin cambios) ... */
            if (ws && ws.readyState === WebSocket.OPEN && symbols.length > 0) {
                const streams = symbols.map(s => `${s.toLowerCase()}@ticker`);
                const payload = { method: "SUBSCRIBE", params: streams, id: 1 };
                ws.send(JSON.stringify(payload));
                console.log("WebSocket: Subscribed to:", symbols);
            } else if (ws && ws.readyState !== WebSocket.OPEN) { console.warn("WebSocket not open, cannot subscribe."); }
        }
        function unsubscribeFromTickers(ws, symbols) { /* ... (sin cambios) ... */
             if (ws && ws.readyState === WebSocket.OPEN && symbols.length > 0) {
                const streams = symbols.map(s => `${s.toLowerCase()}@ticker`);
                const payload = { method: "UNSUBSCRIBE", params: streams, id: 2 };
                ws.send(JSON.stringify(payload));
                console.log("WebSocket: Unsubscribed from:", symbols);
            }
        }
        function connectWebSocket() { /* ... (sin cambios) ... */
            if (webSocket && webSocket.readyState !== WebSocket.CLOSED) { console.log("WebSocket already connecting or open."); return; }
            const symbolsToConnect = [...currentDisplayedCryptos];
            if (symbolsToConnect.length === 0) { console.log("No valid symbols to connect to WebSocket."); return; }
            const streams = symbolsToConnect.map(s => `${s.toLowerCase()}@ticker`).join('/');
            const wsUrl = `${websocketUrl}/${streams}`;
            console.log(`Connecting to WebSocket for valid symbols: ${wsUrl}`);
            webSocket = new WebSocket(wsUrl);
            webSocket.onopen = () => { console.log('WebSocket connection established.'); errorMessage.style.display = 'none'; };
            webSocket.onmessage = (event) => {
                 try {
                    const message = JSON.parse(event.data);
                    if (message.e === '24hrTicker') {
                        const symbol = message.s;
                        const cardData = cryptoDataMap.get(symbol);
                        if (cardData) {
                            const currentPrice = parseFloat(message.c);
                            const oldPrice = cardData.lastPrice;
                            const priceGoesUp = currentPrice >= oldPrice;
                            if (isNaN(currentPrice)) { console.warn(`[Warning ${symbol}] Invalid price received:`, message.c); return; }
                            cardData.lastPrice = currentPrice;
                            cardData.priceChangePercent = parseFloat(message.P);
                            updateCardElement(cardData.priceElement, formatCurrency(currentPrice), true, priceGoesUp);
                            updateChangeBadge(cardData.changeElement, message.P);
                            updateCardElement(cardData.volumeElement, formatCurrency(message.q));
                        }
                    } else if (message.result === null && message.id) { console.log("WebSocket: Received confirmation for request id:", message.id); }
                } catch (parseError) { console.error("Error parsing WebSocket message:", parseError, event.data); }
            };
            webSocket.onerror = (error) => { console.error('WebSocket Error:', error); errorMessage.innerHTML = `<p class="font-medium">¡Error de Conexión!</p><p>Problema con la conexión en tiempo real. Intentando reconectar...</p>`; errorMessage.style.display = 'block'; };
            webSocket.onclose = (event) => {
                console.log(`WebSocket connection closed (code: ${event.code}, reason: ${event.reason}). Attempting to reconnect...`);
                webSocket = null;
                if (currentDisplayedCryptos.length > 0) { setTimeout(connectWebSocket, 5000 + Math.random() * 1000); }
            };
        }

        // --- Handlers para Drag and Drop ---
        function handleDragStart(e) {
            if (e.target.classList.contains('crypto-card')) {
                isDragging = true;
                draggedElement = e.target;
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', draggedElement.dataset.symbol);
                // Usar requestAnimationFrame para asegurar que el navegador aplique el estilo
                requestAnimationFrame(() => {
                    if(draggedElement) draggedElement.classList.add('dragging');
                });
                console.log(`Drag Start (Mouse): ${draggedElement.dataset.symbol}`);
            } else {
                e.preventDefault();
            }
        }

        function handleDragEnd(e) {
            if (draggedElement) {
                 draggedElement.classList.remove('dragging');
                 draggedElement = null;
                 isDragging = false;
                 document.body.classList.remove('dragging-active');
                 // Limpiar indicador visual si existe
                 if (dragOverTarget) {
                     dragOverTarget.classList.remove('drag-over-target');
                     dragOverTarget = null;
                 }
                 console.log(`Drag End (Mouse)`);
                 saveCurrentOrder(); // Guardar orden al finalizar
            }
        }

        function handleDragOver(e) {
            e.preventDefault(); // Necesario para permitir el drop
            if (!isDragging || !draggedElement) return;

            e.dataTransfer.dropEffect = 'move';
            const targetElement = e.target.closest('.crypto-card'); // Encontrar la tarjeta sobre la que estamos

            // Limpiar indicador anterior
            if (dragOverTarget && dragOverTarget !== targetElement) {
                dragOverTarget.classList.remove('drag-over-target');
            }

            // Actualizar el objetivo actual y añadir indicador
            if (targetElement && targetElement !== draggedElement) {
                 dragOverTarget = targetElement;
                 dragOverTarget.classList.add('drag-over-target'); // Añadir clase para feedback visual
            } else {
                 dragOverTarget = null; // Estamos sobre el contenedor o sobre el mismo elemento
            }
        }

        function handleDrop(e) {
            e.preventDefault();
            if (isDragging && draggedElement) {
                const container = cryptoGridContainer;
                // Si soltamos sobre una tarjeta válida (y no sobre sí misma), insertar antes
                if (dragOverTarget && dragOverTarget !== draggedElement) {
                    console.log(`Drop event. Dropping ${draggedElement.dataset.symbol} before ${dragOverTarget.dataset.symbol}`);
                    container.insertBefore(draggedElement, dragOverTarget);
                }
                // Si soltamos sobre el contenedor (no sobre una tarjeta específica) o sobre sí misma (no debería pasar pero por si acaso)
                // y el último elemento sobre el que pasamos fue null (o sea, el final), añadir al final.
                // Esta lógica puede necesitar ajuste si el drop sobre el contenedor debe insertar en otro lugar.
                else if (!dragOverTarget) {
                     console.log(`Drop event. Appending ${draggedElement.dataset.symbol} to the end.`);
                     container.appendChild(draggedElement);
                }

                // Limpiar indicador visual
                if (dragOverTarget) {
                    dragOverTarget.classList.remove('drag-over-target');
                }
            }
            // La limpieza final (quitar clase dragging, etc.) se hace en dragend
        }


        function handleTouchStart(e) {
            const card = e.target.closest('.crypto-card');
            if (card) {
                isDragging = true;
                draggedElement = card;
                // Añadir clase visual con retraso
                setTimeout(() => {
                    if (isDragging && draggedElement) {
                        draggedElement.classList.add('dragging');
                        document.body.classList.add('dragging-active');
                    }
                }, 150);
                console.log(`Touch Start: ${draggedElement.dataset.symbol}`);
            }
        }

        function handleTouchMove(e) {
            if (!isDragging || !draggedElement) return;
            e.preventDefault(); // Prevenir scroll

            const touch = e.touches[0];
            const elementOver = document.elementFromPoint(touch.clientX, touch.clientY);
            const targetCard = elementOver ? elementOver.closest('.crypto-card') : null;

            // Limpiar indicador anterior
             if (dragOverTarget && dragOverTarget !== targetCard) {
                dragOverTarget.classList.remove('drag-over-target');
            }

            // Actualizar objetivo y añadir indicador
            if (targetCard && targetCard !== draggedElement) {
                dragOverTarget = targetCard;
                dragOverTarget.classList.add('drag-over-target');
            } else {
                dragOverTarget = null;
            }
        }

        function handleTouchEnd(e) {
            if (isDragging && draggedElement) {
                // Realizar la inserción final basada en dragOverTarget
                const container = cryptoGridContainer;
                if (dragOverTarget && dragOverTarget !== draggedElement) {
                     console.log(`Touch End. Dropping ${draggedElement.dataset.symbol} before ${dragOverTarget.dataset.symbol}`);
                     container.insertBefore(draggedElement, dragOverTarget);
                } else if (!dragOverTarget) {
                    // Si terminamos sobre el contenedor, añadir al final
                    console.log(`Touch End. Appending ${draggedElement.dataset.symbol} to the end.`);
                    container.appendChild(draggedElement);
                }

                // Limpiar estilos y estado
                draggedElement.classList.remove('dragging');
                if (dragOverTarget) {
                    dragOverTarget.classList.remove('drag-over-target');
                }
                saveCurrentOrder(); // Guardar orden
            }
            // Limpiar siempre
            draggedElement = null;
            isDragging = false;
            dragOverTarget = null;
            document.body.classList.remove('dragging-active');
        }

        function saveCurrentOrder() {
            const orderedSymbols = [...cryptoGridContainer.querySelectorAll('.crypto-card')].map(card => card.dataset.symbol);
            console.log("Saving new card order:", orderedSymbols);
            currentDisplayedCryptos = orderedSymbols;
            localStorage.setItem('userCryptoList', JSON.stringify(currentDisplayedCryptos));
        }

        // --- Funciones para Añadir/Eliminar Crypto ---
        function openAddModal() { /* ... */
            addCryptoErrorMsg.textContent = ''; cryptoSymbolInput.value = '';
            addCryptoModal.classList.remove('opacity-0', 'pointer-events-none');
            addCryptoModal.querySelector('.modal-content').classList.remove('scale-95');
            document.body.classList.add('modal-active'); cryptoSymbolInput.focus();
        }
        function closeAddModal() { /* ... */
            addCryptoModal.classList.add('opacity-0');
            addCryptoModal.querySelector('.modal-content').classList.add('scale-95');
            setTimeout(() => {
                addCryptoModal.classList.add('pointer-events-none');
                if (!chartModal || chartModal.classList.contains('pointer-events-none')) { document.body.classList.remove('modal-active'); }
            }, 250);
        }
        async function addCrypto() { /* ... (sin cambios) ... */
            let symbol = cryptoSymbolInput.value.trim().toUpperCase();
            addCryptoErrorMsg.textContent = '';
            const btn = confirmAddCryptoBtn;
            const btnText = btn.querySelector('.button-text');
            const btnLoader = btn.querySelector('.button-loader');
            if (!symbol) { addCryptoErrorMsg.textContent = 'Por favor, ingresa un símbolo.'; return; }
            if (!symbol.endsWith('USDT')) { symbol += 'USDT'; }
            let currentList = getUserCryptos();
            if (currentList.includes(symbol)) { addCryptoErrorMsg.textContent = `${symbol} ya está en la lista.`; return; }
            console.log("Attempting to validate and add crypto:", symbol);
            btnText.classList.add('invisible'); btnLoader.classList.remove('hidden'); btn.disabled = true;
            try {
                const checkUrl = `${tickerApiUrl}?symbol=${symbol}`;
                const checkResponse = await fetch(checkUrl);
                if (!checkResponse.ok) {
                    let errorMsg = `Símbolo '${symbol}' no encontrado en Binance.`;
                    try { const errorData = await checkResponse.json(); if (errorData && errorData.msg) { errorMsg = `Error de Binance: ${errorData.msg}`; } } catch (e) { /* Ignorar */ }
                    throw new Error(errorMsg);
                }
                console.log("Symbol validation successful for:", symbol);
                const newList = [...currentList, symbol];
                saveUserCryptos(newList); closeAddModal(); await fetchInitialDataAndBuildGrid();
            } catch (error) {
                console.error("Error adding crypto:", error);
                addCryptoErrorMsg.textContent = error.message || 'No se pudo verificar el símbolo. Inténtalo de nuevo.';
            } finally { btnText.classList.remove('invisible'); btnLoader.classList.add('hidden'); btn.disabled = false; }
        }
        function removeCrypto(symbolToRemove) { /* ... (sin cambios) ... */
            console.log("Removing crypto:", symbolToRemove);
            let currentList = getUserCryptos();
            const newList = currentList.filter(symbol => symbol !== symbolToRemove);
            saveUserCryptos(newList);
            cryptoDataMap.delete(symbolToRemove);
            const cardToRemove = cryptoGridContainer.querySelector(`.crypto-card[data-symbol="${symbolToRemove}"]`);
            if (cardToRemove) { cardToRemove.remove(); }
            if (webSocket && webSocket.readyState === WebSocket.OPEN) { unsubscribeFromTickers(webSocket, [symbolToRemove]); webSocket.close(); }
             if (newList.length === 0) { cryptoGridContainer.innerHTML = '<p class="text-center text-gray-500 col-span-full">No hay criptomonedas para mostrar. Añade algunas usando el botón "+".</p>'; }
        }

        // --- Función INICIAL para Cargar Datos y Construir Cuadrícula ---
        async function fetchInitialDataAndBuildGrid() {
              loadingIndicator.style.display = 'block';
              errorMessage.style.display = 'none';
             try {
                 const userRequestedCryptos = getUserCryptos();
                 console.log("User requested cryptos:", userRequestedCryptos);
                 if (userRequestedCryptos.length === 0) { /* ... manejo lista vacía ... */
                    loadingIndicator.style.display = 'none';
                    cryptoGridContainer.innerHTML = '<p class="text-center text-gray-500 col-span-full">Lista vacía. Añade criptomonedas.</p>';
                    currentDisplayedCryptos = [];
                    if (webSocket && webSocket.readyState === WebSocket.OPEN) webSocket.close();
                    return;
                 }
                 console.log("Fetching all tickers from:", tickerApiUrl);
                 const response = await fetch(tickerApiUrl);
                 if (!response.ok) { /* ... manejo error fetch ... */
                     let errorText = `${response.status} ${response.statusText}`;
                     try { const errorBody = await response.text(); console.error("Error body from API (if any):", errorBody); if (errorBody) { errorText += ` - ${errorBody.substring(0, 150)}`; } } catch(e) { console.warn("Could not read error response body."); }
                     throw new Error(`HTTP error! ${errorText}`);
                 }
                 const allTickers = await response.json();
                 const availableSymbols = new Set(allTickers.map(t => t.symbol));
                 const validCryptosToDisplay = userRequestedCryptos.filter(symbol => {
                     const exists = availableSymbols.has(symbol);
                     if (!exists) { console.warn(`Symbol ${symbol} requested by user but not found in API response. Skipping.`); }
                     return exists;
                 });
                 console.log("Valid cryptos to display after API check:", validCryptosToDisplay);
                 if (JSON.stringify(validCryptosToDisplay) !== JSON.stringify(userRequestedCryptos)) {
                    console.log("User list contained invalid symbols. Updating stored list.");
                    saveUserCryptos(validCryptosToDisplay);
                 }
                 currentDisplayedCryptos = [...validCryptosToDisplay];
                 cryptoGridContainer.innerHTML = '';
                 cryptoDataMap.clear();
                  if (currentDisplayedCryptos.length === 0) { /* ... manejo lista vacía después de validar ... */
                     loadingIndicator.style.display = 'none';
                     cryptoGridContainer.innerHTML = '<p class="text-center text-gray-500 col-span-full">Ninguna de las criptomonedas añadidas se encontró en la API.</p>';
                     if (webSocket && webSocket.readyState === WebSocket.OPEN) webSocket.close();
                     return;
                 }
                 const foundDataMap = new Map(allTickers.map(ticker => [ticker.symbol, ticker]));
                 currentDisplayedCryptos.forEach(symbol => {
                     const crypto = foundDataMap.get(symbol);
                     if (!crypto) return;
                     const card = document.createElement('div');
                     card.className = 'crypto-card border rounded-lg p-4 shadow-sm hover:shadow-md flex flex-col space-y-1 relative';
                     card.dataset.symbol = symbol;
                     card.setAttribute('draggable', 'true');
                     card.addEventListener('dragstart', handleDragStart);
                     card.addEventListener('dragend', handleDragEnd);
                     card.addEventListener('touchstart', handleTouchStart, { passive: false });
                     card.addEventListener('touchmove', handleTouchMove, { passive: false });
                     card.addEventListener('touchend', handleTouchEnd);
                     card.addEventListener('touchcancel', handleTouchEnd);
                     card.addEventListener('click', (e) => { if (e.target.closest('.remove-crypto-btn')) return; if (!isDragging) { displayChart(symbol); } else { console.log("Click prevented during/after drag."); } });
                     const removeBtn = document.createElement('button');
                     removeBtn.className = 'remove-crypto-btn text-gray-400 hover:text-white';
                     removeBtn.innerHTML = '&times;';
                     removeBtn.title = `Eliminar ${symbol.replace('USDT','')}`;
                     removeBtn.onclick = (e) => { e.stopPropagation(); removeCrypto(symbol); };
                     card.appendChild(removeBtn);
                     const symbolElement = document.createElement('div');
                     symbolElement.className = 'text-base font-semibold pr-5';
                     symbolElement.textContent = symbol.replace('USDT', '');
                     const priceElement = document.createElement('div');
                     priceElement.className = 'text-lg font-bold crypto-card-price';
                     const changeBadgeElement = document.createElement('div');
                     changeBadgeElement.className = 'change-badge crypto-card-change self-start';
                     const volumeElement = document.createElement('div');
                     volumeElement.className = 'text-xs text-gray-500 dark:text-gray-400 crypto-card-volume pt-1';
                     priceElement.innerHTML = formatCurrency(crypto.lastPrice);
                     updateChangeBadge(changeBadgeElement, crypto.priceChangePercent);
                     volumeElement.innerHTML = formatCurrency(crypto.quoteVolume);
                     cryptoDataMap.set(symbol, { cardElement: card, priceElement: priceElement, changeElement: changeBadgeElement, volumeElement: volumeElement, lastPrice: parseFloat(crypto.lastPrice) || 0, priceChangePercent: parseFloat(crypto.priceChangePercent) || 0 });
                     card.appendChild(symbolElement);
                     card.appendChild(priceElement);
                     card.appendChild(changeBadgeElement);
                     card.appendChild(volumeElement);
                     cryptoGridContainer.appendChild(card);
                 });
                  loadingIndicator.style.display = 'none';
                  if (webSocket && webSocket.readyState === WebSocket.OPEN) { webSocket.close(); }
                  connectWebSocket();
             } catch (error) { /* ... (manejo de error sin cambios) ... */
                 console.error('fetchInitialDataAndBuildGrid caught an error:');
                 console.log("Raw error object:", error); console.dir(error);
                 if (error instanceof Error) { console.error("Error Name:", error.name); console.error("Error Message:", error.message); console.error("Error Stack:", error.stack); }
                 else { console.error("Caught item is not an Error instance:", typeof error); }
                 try { const errorString = JSON.stringify(error); console.error("Stringified error:", errorString); } catch (e) { console.warn("Could not stringify the error object."); }
                 loadingIndicator.style.display = 'none';
                 errorMessage.innerHTML = `<p class="font-medium">¡Error al Cargar Datos Iniciales!</p><p>No se pudo obtener la información de la API.</p><p class="text-xs mt-1">Posibles causas: Problema de red, API de Binance no disponible o bloqueo (CORS).</p><p class="text-xs mt-1">Revisa la consola del navegador (F12) y la pestaña 'Network' para más detalles técnicos.</p>`;
                 errorMessage.style.display = 'block';
             }
        }

        // --- Inicialización Principal ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM fully loaded and parsed.");
            // Obtener referencias a elementos del DOM
            cryptoGridContainer = document.getElementById('crypto-grid-container');
            loadingIndicator = document.getElementById('loading');
            errorMessage = document.getElementById('error-message');
            chartModal = document.getElementById('chart-modal');
            chartModalTitle = document.getElementById('chart-modal-title');
            closeModalBtn = document.getElementById('close-modal-btn');
            fullscreenBtn = document.getElementById('fullscreen-btn');
            iframeContainer = document.getElementById('tradingview-iframe-container');
            chartLoader = document.getElementById('chart-loader');
            chartError = document.getElementById('chart-error');
            addCryptoBtn = document.getElementById('add-crypto-btn');
            addCryptoModal = document.getElementById('add-crypto-modal');
            closeAddModalBtn = document.getElementById('close-add-modal-btn');
            cryptoSymbolInput = document.getElementById('crypto-symbol-input');
            confirmAddCryptoBtn = document.getElementById('confirm-add-crypto-btn');
            addCryptoErrorMsg = document.getElementById('add-crypto-error');

            // Carga de datos y listeners
            fetchInitialDataAndBuildGrid();
            if (fullscreenBtn) fullscreenBtn.addEventListener('click', toggleFullscreen);
            if (closeModalBtn) closeModalBtn.addEventListener('click', closeModal);
            if (chartModal) {
                chartModal.addEventListener('click', (event) => { if (event.target === chartModal) { closeModal(); } });
                document.addEventListener('keydown', (event) => { if (event.key === 'Escape' && !chartModal.classList.contains('pointer-events-none')) { closeModal(); } });
            }
            if (addCryptoBtn) addCryptoBtn.addEventListener('click', openAddModal);
            if (closeAddModalBtn) closeAddModalBtn.addEventListener('click', closeAddModal);
            if (addCryptoModal) addCryptoModal.addEventListener('click', (event) => { if (event.target === addCryptoModal) { closeAddModal(); } });
            if (confirmAddCryptoBtn) confirmAddCryptoBtn.addEventListener('click', addCrypto);
            if (cryptoSymbolInput) cryptoSymbolInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') addCrypto(); });

            // Listeners Drag & Drop Contenedor
            if (cryptoGridContainer) {
                cryptoGridContainer.addEventListener('dragover', handleDragOver);
                cryptoGridContainer.addEventListener('drop', handleDrop);
                // *** CAMBIO: Añadir listener touchmove al contenedor también ***
                // Esto ayuda a detectar sobre qué elemento estamos incluso si el dedo
                // se mueve fuera de la tarjeta original pero sigue sobre la cuadrícula.
                cryptoGridContainer.addEventListener('touchmove', handleTouchMove, { passive: false });
                // Touchend y Touchcancel se pueden escuchar en el documento para asegurar
                // que se capturen incluso si el dedo se levanta fuera del contenedor.
                document.addEventListener('touchend', handleTouchEnd);
                document.addEventListener('touchcancel', handleTouchEnd);

            } else {
                 console.error("Crypto grid container not found! Drag and drop will not work.");
            }
        });

    </script>

</body>
</html>

