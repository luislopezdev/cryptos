<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crypto Tracker - Binance</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lightweight-charts/dist/lightweight-charts.standalone.production.js"></script>
    <style>
        /* Estilo para la fuente Inter */
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Estilos para el indicador de carga */
        .loader {
            border: 4px solid #f3f3f3; /* Light grey */
            border-top: 4px solid #3b82f6; /* Blue-500 */
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto; /* Centrado */
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        /* Estilos básicos para el Modal */
        .modal {
            transition: opacity 0.25s ease;
        }
        .modal-content {
             transition: transform 0.25s ease;
        }
        /* Ocultar scrollbar cuando el modal está abierto */
        body.modal-active {
            overflow: hidden;
        }
    </style>
     <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body class="bg-gradient-to-br from-gray-100 to-gray-200 text-gray-900 min-h-screen">

    <div class="container mx-auto p-4 sm:p-6 md:p-8 max-w-5xl">
        <header class="mb-10 text-center">
             <h1 class="text-4xl md:text-5xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-blue-600 to-indigo-700 pb-2">
                Monitor de Criptomonedas
            </h1>
            <p class="text-gray-600 mt-2 text-lg">Precios en tiempo real desde Binance (USDT)</p>
        </header>

        <div id="crypto-container" class="bg-white rounded-xl shadow-lg overflow-hidden">
            <div class="p-5 md:p-8">
                <div id="loading" class="text-center py-10">
                    <div class="loader"></div>
                    <p class="text-gray-500 mt-3">Cargando datos...</p>
                </div>
                <div id="error-message" class="hidden text-center text-red-700 bg-red-100 p-4 rounded-lg border border-red-200">
                    <p class="font-medium">¡Error!</p>
                    <p>No se pudieron cargar los datos. Por favor, inténtalo de nuevo más tarde.</p>
                </div>
                <div id="crypto-table-container" class="overflow-x-auto">
                     </div>
            </div>
        </div>

        <footer class="mt-10 text-center text-gray-500 text-sm">
            Datos proporcionados por la API pública de Binance.
            <p>Listo para desplegar en Firebase Hosting.</p>
        </footer>
    </div>

    <div id="chart-modal" class="modal pointer-events-none fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-60 opacity-0">
        <div class="modal-content bg-white rounded-lg shadow-xl w-11/12 max-w-3xl p-4 md:p-6 transform scale-95">
            <div class="flex justify-between items-center border-b border-gray-200 pb-3 mb-4">
                <h3 id="chart-modal-title" class="text-xl font-semibold text-gray-800">Gráfico de Precios</h3>
                <button id="close-modal-btn" class="text-gray-500 hover:text-gray-700 text-2xl">&times;</button>
            </div>
            <div id="chart-container" class="w-full h-64 md:h-96 relative">
                <div id="chart-loader" class="absolute inset-0 flex items-center justify-center bg-white bg-opacity-75 z-10">
                    <div class="loader"></div>
                 </div>
                 <div id="chart-error" class="absolute inset-0 flex items-center justify-center bg-white z-10 hidden text-red-600 p-4 text-center">
                     </div>
                </div>
        </div>
    </div>


    <script>
        // URL de la API de Binance para tickers y klines (candlesticks)
        const tickerApiUrl = 'https://api.binance.com/api/v3/ticker/24hr';
        const klinesApiUrl = 'https://api.binance.com/api/v3/klines';
        // Lista de símbolos principales
        const mainCryptos = [
            'BTCUSDT', 'ETHUSDT', 'BNBUSDT', 'SOLUSDT', 'XRPUSDT', 'ADAUSDT',
            'DOGEUSDT', 'AVAXUSDT', 'DOTUSDT', 'MATICUSDT', 'LINKUSDT', 'SHIBUSDT'
        ];

        // Elementos del DOM
        const cryptoTableContainer = document.getElementById('crypto-table-container');
        const loadingIndicator = document.getElementById('loading');
        const errorMessage = document.getElementById('error-message');
        const chartModal = document.getElementById('chart-modal');
        const chartModalTitle = document.getElementById('chart-modal-title');
        const closeModalBtn = document.getElementById('close-modal-btn');
        const chartContainer = document.getElementById('chart-container');
        const chartLoader = document.getElementById('chart-loader');
        const chartError = document.getElementById('chart-error');

        let chart = null; // Variable para mantener la instancia del gráfico

        // --- Funciones de Formato ---
        function formatCurrency(number) {
            const num = parseFloat(number);
            if (isNaN(num)) { return '<span class="text-gray-400">N/A</span>'; }
            if (num > 1_000_000_000) { return `$${(num / 1_000_000_000).toFixed(2)}B`; }
            if (num > 1_000_000) { return `$${(num / 1_000_000).toFixed(2)}M`; }
            return num.toLocaleString('en-US', {
                style: 'currency', currency: 'USD',
                minimumFractionDigits: num > 1 ? 2 : (num > 0.0001 ? 4 : 6),
                maximumFractionDigits: num > 1 ? 4 : 6
            });
        }
        function formatPercentage(percent) {
             const num = parseFloat(percent);
             if (isNaN(num)) { return '<span class="text-gray-400">N/A</span>'; }
             const changeColor = num >= 0 ? 'text-green-600' : 'text-red-600';
             const sign = num >= 0 ? '+' : '';
             return `<span class="font-semibold ${changeColor}">${sign}${num.toFixed(2)}%</span>`;
        }

        // --- Funciones del Modal ---
        function openModal() {
            chartModal.classList.remove('opacity-0', 'pointer-events-none');
            chartModal.querySelector('.modal-content').classList.remove('scale-95');
            document.body.classList.add('modal-active');
        }

        function closeModal() {
            chartModal.classList.add('opacity-0');
            chartModal.querySelector('.modal-content').classList.add('scale-95');
            setTimeout(() => {
                chartModal.classList.add('pointer-events-none');
                document.body.classList.remove('modal-active');
                if (chart) {
                    console.log("Removing chart instance on close.");
                    chart.remove();
                    chart = null;
                }
                chartLoader.style.display = 'none';
                chartError.style.display = 'none';
                chartError.textContent = '';
            }, 250);
        }

        // --- Funciones del Gráfico ---
        async function displayChart(symbol) {
            chartModalTitle.textContent = `Gráfico de ${symbol.replace('USDT', '')}/USDT (Diario)`;
            chartLoader.style.display = 'flex';
            chartError.style.display = 'none';
            chartError.textContent = '';
            openModal();
            await new Promise(resolve => setTimeout(resolve, 50)); // Esperar a que el modal sea visible

            try {
                if (chart) {
                    console.warn("Removing lingering chart instance before creating new one.");
                    chart.remove();
                    chart = null;
                }

                // *** NUEVA VERIFICACIÓN: Asegurarse de que LightweightCharts esté cargado ***
                if (typeof LightweightCharts === 'undefined') {
                    console.error('LightweightCharts library is not loaded.');
                    throw new Error('La biblioteca de gráficos (LightweightCharts) no se ha cargado.');
                }
                 if (typeof LightweightCharts.createChart !== 'function') {
                     console.error('LightweightCharts.createChart is not a function. Library might be corrupted or loaded incorrectly.');
                     throw new Error('La función para crear gráficos (createChart) no está disponible.');
                 }
                 console.log('LightweightCharts library and createChart function seem available.');

                // Validar contenedor del gráfico
                if (!chartContainer || chartContainer.clientHeight === 0 || chartContainer.clientWidth === 0) {
                    console.error('Chart container is not valid or has zero dimensions.');
                    throw new Error('El contenedor del gráfico no es válido o no está visible.');
                }

                // 1. Obtener datos históricos (sin cambios aquí)
                const interval = '1d';
                const limit = 90;
                const apiUrl = `${klinesApiUrl}?symbol=${symbol}&interval=${interval}&limit=${limit}`;
                const response = await fetch(apiUrl);
                if (!response.ok) { /* ... manejo de error de fetch ... */
                    let errorDetails = `HTTP error! status: ${response.status}`;
                    try {
                        const errorBody = await response.json();
                        errorDetails += ` - ${errorBody.msg || JSON.stringify(errorBody)}`;
                    } catch (e) { errorDetails += ` - ${response.statusText}`; }
                    console.error(`Error fetching klines for ${symbol}: ${errorDetails}`);
                    throw new Error(errorDetails);
                }
                const klinesData = await response.json();

                // 2. Procesar datos (sin cambios aquí)
                if (!Array.isArray(klinesData) || klinesData.length === 0) { throw new Error('No se recibieron datos para el gráfico o el formato es inválido.'); }
                const chartData = klinesData.map(kline => { /* ... */
                    if (!Array.isArray(kline) || kline.length < 5) { console.warn(`Invalid kline data skipped for ${symbol}:`, kline); return null; }
                    return { time: kline[0] / 1000, value: parseFloat(kline[4]) };
                }).filter(item => item !== null && !isNaN(item.value));
                if (chartData.length === 0) { throw new Error('No hay puntos de datos válidos para el gráfico después del procesamiento.'); }


                // 3. Crear instancia del gráfico
                console.log("Attempting to create chart instance for:", symbol);
                try {
                    // *** ENVOLVER LA CREACIÓN EN SU PROPIO TRY...CATCH ***
                    chart = LightweightCharts.createChart(chartContainer, {
                        width: chartContainer.clientWidth,
                        height: chartContainer.clientHeight,
                        layout: { background: { color: '#ffffff' }, textColor: '#333' },
                        grid: { vertLines: { color: '#f0f0f0' }, horzLines: { color: '#f0f0f0' } },
                        timeScale: { timeVisible: true, secondsVisible: false },
                        rightPriceScale: { scaleMargins: { top: 0.1, bottom: 0.1 } },
                    });
                    console.log("Chart instance created:", chart);
                } catch (creationError) {
                    console.error("Error during LightweightCharts.createChart:", creationError);
                    throw new Error(`Falló la creación del gráfico: ${creationError.message}`);
                }


                // Verificar que el gráfico se creó correctamente Y TIENE EL MÉTODO
                 if (!chart || typeof chart.addLineSeries !== 'function') {
                    console.error('Chart object is invalid or addLineSeries method is missing AFTER creation attempt.');
                    // Limpiar instancia si es inválida
                    if(chart && typeof chart.remove === 'function') chart.remove();
                    chart = null;
                    throw new Error('El objeto del gráfico es inválido o falta el método addLineSeries después de intentar crearlo.');
                }

                // Añadir la serie de línea
                const lineSeries = chart.addLineSeries({ color: '#3b82f6', lineWidth: 2 });
                lineSeries.setData(chartData);
                chart.timeScale().fitContent();
                chartLoader.style.display = 'none';

            } catch (error) {
                console.error(`Error displaying chart for ${symbol}:`, error.message || error);
                chartLoader.style.display = 'none';
                chartError.textContent = `Error al cargar el gráfico para ${symbol}: ${error.message || 'Error desconocido'}`;
                chartError.style.display = 'flex';
                if (chart) { // Limpiar si hubo error después de crear
                    chart.remove();
                    chart = null;
                }
            }
        }

         // Redimensionar gráfico
        window.addEventListener('resize', () => {
            if (chart && !chartModal.classList.contains('pointer-events-none')) {
                setTimeout(() => {
                     if (chart) {
                         chart.resize(chartContainer.clientWidth, chartContainer.clientHeight);
                    }
                }, 100);
            }
        });


        // --- Función Principal para Cargar Datos de la Tabla ---
        async function fetchCryptoData() {
            // ... (resto de la función sin cambios) ...
             if (!cryptoTableContainer.querySelector('table')) {
                loadingIndicator.style.display = 'block';
            }
            errorMessage.style.display = 'none';

            try {
                const response = await fetch(tickerApiUrl);
                if (!response.ok) { throw new Error(`HTTP error! status: ${response.status}`); }
                const data = await response.json();
                const filteredData = data.filter(ticker => mainCryptos.includes(ticker.symbol));

                loadingIndicator.style.display = 'none';

                let table = cryptoTableContainer.querySelector('table');
                if (!table) {
                    table = document.createElement('table');
                    table.className = 'min-w-full divide-y divide-gray-300';
                    table.innerHTML = `
                        <thead class="bg-gray-100">
                            <tr>
                                <th scope="col" class="px-4 py-3.5 text-left text-sm font-semibold text-gray-900">Símbolo</th>
                                <th scope="col" class="px-4 py-3.5 text-left text-sm font-semibold text-gray-900">Precio Actual</th>
                                <th scope="col" class="px-4 py-3.5 text-left text-sm font-semibold text-gray-900">Cambio (24h)</th>
                                <th scope="col" class="px-4 py-3.5 text-left text-sm font-semibold text-gray-900">Volumen (24h)</th>
                            </tr>
                        </thead>
                        <tbody class="divide-y divide-gray-200 bg-white"></tbody>
                    `;
                     cryptoTableContainer.appendChild(table);
                }

                const tbody = table.querySelector('tbody');
                tbody.innerHTML = ''; // Limpiar tabla

                filteredData.sort((a, b) => mainCryptos.indexOf(a.symbol) - mainCryptos.indexOf(b.symbol));

                filteredData.forEach(crypto => {
                    const row = tbody.insertRow();
                    row.className = 'transition-colors duration-150 ease-in-out hover:bg-blue-50 cursor-pointer';
                    row.dataset.symbol = crypto.symbol;

                    row.addEventListener('click', () => {
                        displayChart(crypto.symbol);
                    });

                    const cellSymbol = row.insertCell();
                    cellSymbol.className = 'whitespace-nowrap px-4 py-4 text-sm';
                    cellSymbol.innerHTML = `<div class="font-medium text-gray-900">${crypto.symbol.replace('USDT', '')}</div><div class="text-gray-500">/ USDT</div>`;
                    const cellPrice = row.insertCell();
                    cellPrice.className = 'whitespace-nowrap px-4 py-4 text-sm text-gray-800';
                    cellPrice.innerHTML = formatCurrency(crypto.lastPrice);
                    const cellChange = row.insertCell();
                    cellChange.className = 'whitespace-nowrap px-4 py-4 text-sm';
                    cellChange.innerHTML = formatPercentage(crypto.priceChangePercent);
                    const cellVolume = row.insertCell();
                    cellVolume.className = 'whitespace-nowrap px-4 py-4 text-sm text-gray-600';
                    cellVolume.innerHTML = formatCurrency(crypto.quoteVolume);
                });

            } catch (error) {
                console.error('Error fetching crypto data:', error);
                if (!cryptoTableContainer.querySelector('table')) {
                    loadingIndicator.style.display = 'none';
                    errorMessage.style.display = 'block';
                }
            }
        }

        // --- Event Listeners ---
        document.addEventListener('DOMContentLoaded', fetchCryptoData);
        setInterval(fetchCryptoData, 60000);
        closeModalBtn.addEventListener('click', closeModal);
        chartModal.addEventListener('click', (event) => {
            if (event.target === chartModal) { closeModal(); }
        });
         document.addEventListener('keydown', (event) => {
            if (event.key === 'Escape' && !chartModal.classList.contains('pointer-events-none')) {
                closeModal();
            }
        });

    </script>

</body>
</html>
