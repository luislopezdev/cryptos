<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crypto Tracker - Binance (Real-Time with TradingView Widget)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { font-family: 'Inter', sans-serif; }
        .loader { border: 4px solid #f3f3f3; border-top: 4px solid #3b82f6; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; margin: 20px auto; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .modal { transition: opacity 0.25s ease; }
        .modal-content { transition: transform 0.25s ease; }
        body.modal-active { overflow: hidden; }
        .price-up { animation: flash-green 0.7s ease-out; }
        .price-down { animation: flash-red 0.7s ease-out; }
        @keyframes flash-green { 0% { background-color: rgba(16, 185, 129, 0.3); } 100% { background-color: transparent; } }
        @keyframes flash-red { 0% { background-color: rgba(220, 38, 38, 0.3); } 100% { background-color: transparent; } }
        #tradingview-widget-container { min-height: 320px; }
        @media (min-width: 768px) { #tradingview-widget-container { min-height: 384px; } }
    </style>
     <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body class="bg-gradient-to-br from-gray-100 to-gray-200 text-gray-900 min-h-screen">

    <div class="container mx-auto p-4 sm:p-6 md:p-8 max-w-5xl">
        <header class="mb-10 text-center">
             <h1 class="text-4xl md:text-5xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-blue-600 to-indigo-700 pb-2">
                Monitor de Criptomonedas
            </h1>
            <p class="text-gray-600 mt-2 text-lg">Precios en tiempo real desde Binance (USDT)</p>
        </header>

        <div id="crypto-container" class="bg-white rounded-xl shadow-lg overflow-hidden">
            <div class="p-5 md:p-8">
                <div id="loading" class="text-center py-10">
                    <div class="loader"></div>
                    <p class="text-gray-500 mt-3">Cargando datos iniciales...</p>
                </div>
                <div id="error-message" class="hidden text-center text-red-700 bg-red-100 p-4 rounded-lg border border-red-200">
                    </div>
                <div id="crypto-table-container" class="overflow-x-auto">
                     </div>
            </div>
        </div>

        <footer class="mt-10 text-center text-gray-500 text-sm">
            Datos proporcionados por la API pública y WebSocket de Binance. Gráficos por TradingView.
            <p>Listo para desplegar en Firebase Hosting.</p>
        </footer>
    </div>

    <div id="chart-modal" class="modal pointer-events-none fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-60 opacity-0">
        <div class="modal-content bg-white rounded-lg shadow-xl w-11/12 max-w-4xl p-4 md:p-6 transform scale-95">
            <div class="flex justify-between items-center border-b border-gray-200 pb-3 mb-4">
                <h3 id="chart-modal-title" class="text-xl font-semibold text-gray-800">Gráfico de Precios</h3>
                <button id="close-modal-btn" class="text-gray-500 hover:text-gray-700 text-2xl">&times;</button>
            </div>
            <div class="relative w-full h-80 md:h-96">
                 <div id="chart-loader" class="absolute inset-0 flex items-center justify-center bg-white bg-opacity-75 z-10">
                    <div class="loader"></div>
                 </div>
                 <div id="chart-error" class="absolute inset-0 flex items-center justify-center bg-white z-10 hidden text-red-600 p-4 text-center"></div>
                 <div id="tradingview-widget-container" class="w-full h-full">
                     </div>
            </div>
        </div>
    </div>

    <script type="text/javascript" src="https://s3.tradingview.com/tv.js" defer></script>


    <script>
        // URLs API y WebSocket
        const tickerApiUrl = 'https://api.binance.com/api/v3/ticker/24hr';
        const websocketUrl = 'wss://stream.binance.com:9443/ws';

        // Símbolos
        const mainCryptos = [
            'BTCUSDT', 'ETHUSDT', 'BNBUSDT', 'SOLUSDT', 'XRPUSDT', 'ADAUSDT',
            'DOGEUSDT', 'AVAXUSDT', 'DOTUSDT', 'MATICUSDT', 'LINKUSDT', 'SHIBUSDT'
        ];

        // Elementos del DOM
        const cryptoTableContainer = document.getElementById('crypto-table-container');
        const loadingIndicator = document.getElementById('loading');
        const errorMessage = document.getElementById('error-message');
        const chartModal = document.getElementById('chart-modal');
        const chartModalTitle = document.getElementById('chart-modal-title');
        const closeModalBtn = document.getElementById('close-modal-btn');
        const widgetContainer = document.getElementById('tradingview-widget-container');
        const chartLoader = document.getElementById('chart-loader');
        const chartError = document.getElementById('chart-error');

        let currentWidget = null;
        let cryptoDataMap = new Map();
        let webSocket = null;
        let tradingViewReady = false; // Flag para saber si TradingView está listo

        // --- Funciones de Formato ---
        function formatCurrency(number) { /* ... */
            const num = parseFloat(number);
            if (isNaN(num)) { return '<span class="text-gray-400">N/A</span>'; }
            if (num > 1_000_000_000) { return `$${(num / 1_000_000_000).toFixed(2)}B`; }
            if (num > 1_000_000) { return `$${(num / 1_000_000).toFixed(2)}M`; }
            return num.toLocaleString('en-US', { style: 'currency', currency: 'USD', minimumFractionDigits: num > 1 ? 2 : (num > 0.0001 ? 4 : 6), maximumFractionDigits: num > 1 ? 4 : 6 });
        }
        function formatPercentage(percent) { /* ... */
             const num = parseFloat(percent);
             if (isNaN(num)) { return '<span class="text-gray-400">N/A</span>'; }
             const sign = num >= 0 ? '+' : '';
             return `<span class="font-semibold">${sign}${num.toFixed(2)}%</span>`;
        }

        // --- Funciones del Modal ---
        function openModal() { /* ... */
             chartModal.classList.remove('opacity-0', 'pointer-events-none');
             chartModal.querySelector('.modal-content').classList.remove('scale-95');
             document.body.classList.add('modal-active');
        }
        function closeModal() { /* ... */
            chartModal.classList.add('opacity-0');
            chartModal.querySelector('.modal-content').classList.add('scale-95');
            setTimeout(() => {
                chartModal.classList.add('pointer-events-none');
                document.body.classList.remove('modal-active');
                if (widgetContainer) { widgetContainer.innerHTML = ''; }
                currentWidget = null;
                chartLoader.style.display = 'none';
                chartError.style.display = 'none';
                chartError.textContent = '';
            }, 250);
        }

        // --- Función para mostrar Widget de TradingView ---
        function displayChart(symbol) {
            console.log(`Attempting to display TradingView Widget for ${symbol}`);
            chartModalTitle.textContent = `Gráfico de ${symbol.replace('USDT', '')}/USDT`;
            chartLoader.style.display = 'flex';
            chartError.style.display = 'none';
            chartError.textContent = '';
            let widgetReady = false;
            let loadingTimeoutId = null;

            // Limpiar contenedor
            if (widgetContainer) {
                widgetContainer.innerHTML = '';
            } else {
                 console.error("Widget container not found!");
                 chartError.textContent = 'Error interno: No se encontró el contenedor del gráfico.';
                 chartError.style.display = 'flex';
                 openModal();
                 return;
            }

            openModal(); // Abrir el modal

            // Timeout de 30 segundos (se mantiene)
            loadingTimeoutId = setTimeout(() => {
                if (!widgetReady) {
                    console.error(`TradingView Widget for ${symbol} did not load within 30 seconds.`);
                    chartLoader.style.display = 'none';
                    chartError.textContent = `El gráfico para ${symbol} tardó demasiado en cargar o falló. Verifica tu conexión o inténtalo más tarde.`;
                    chartError.style.display = 'flex';
                    if (widgetContainer) widgetContainer.innerHTML = '';
                    currentWidget = null;
                }
            }, 30000);

            try {
                 // Verificar TradingView (usar flag global)
                 if (!tradingViewReady || typeof TradingView === 'undefined' || typeof TradingView.widget !== 'function') {
                     clearTimeout(loadingTimeoutId);
                     throw new Error('La funcionalidad de TradingView Widget no está disponible o no se ha inicializado correctamente.');
                 }
                 console.log("TradingView Widget function is available.");

                 // Verificar dimensiones del contenedor
                 if (!widgetContainer || widgetContainer.clientHeight === 0 || widgetContainer.clientWidth === 0) {
                     clearTimeout(loadingTimeoutId);
                     console.error('Widget container has zero dimensions just before widget creation.');
                     // Intentar forzar un reflow puede ayudar a veces, aunque no es ideal
                     // await new Promise(resolve => requestAnimationFrame(resolve));
                     // if (widgetContainer.clientHeight === 0 || widgetContainer.clientWidth === 0) {
                         throw new Error('El contenedor del gráfico no tiene dimensiones válidas.');
                     // }
                 }
                 console.log(`Widget container dimensions before creation: ${widgetContainer.clientWidth}x${widgetContainer.clientHeight}`);

                 console.log("Creating widget...");
                 // Crear el widget (configuración simplificada)
                 currentWidget = new TradingView.widget({
                     "width": "100%",
                     "height": "100%",
                     "symbol": `BINANCE:${symbol}`,
                     "interval": "D",
                     "timezone": "Etc/UTC",
                     "theme": "light",
                     "style": "3", // Gráfico de línea
                     "locale": "es",
                     "enable_publishing": false,
                     "hide_side_toolbar": true, // Ocultar herramientas de dibujo
                     "allow_symbol_change": false,
                     "container_id": "tradingview-widget-container",
                      "onReady": function() {
                         widgetReady = true;
                         clearTimeout(loadingTimeoutId); // Cancelar timeout al cargar
                         console.log(`TradingView Widget for ${symbol} is ready (onReady fired).`);
                         if (chartError.style.display === 'none') {
                             chartLoader.style.display = 'none'; // Ocultar loader
                         } else {
                             console.warn("onReady fired, but timeout error was already displayed.");
                         }
                     }
                 });
                 console.log("TradingView widget instance created (async loading).");

            } catch (error) {
                 clearTimeout(loadingTimeoutId);
                 console.error(`Error creating TradingView Widget for ${symbol}:`, error);
                 chartLoader.style.display = 'none';
                 chartError.textContent = `Error al crear el gráfico para ${symbol}: ${error.message || 'Error desconocido'}`;
                 chartError.style.display = 'flex';
                 if (widgetContainer) widgetContainer.innerHTML = '';
                 currentWidget = null;
            }
        }

        // --- Funciones de Actualización de Tabla (WebSocket) ---
        function updateTableCell(cellElement, newValue, isPriceChange = false, priceGoesUp = false) { /* ... */
             if (cellElement) {
                 cellElement.innerHTML = newValue;
                 if (isPriceChange) {
                     cellElement.classList.remove('price-up', 'price-down');
                     void cellElement.offsetWidth;
                     cellElement.classList.add(priceGoesUp ? 'price-up' : 'price-down');
                 }
             }
        }
        function updateChangeColor(cellElement, percentValue) { /* ... */
              if (cellElement) {
                 const num = parseFloat(percentValue);
                 const changeColor = isNaN(num) || num >= 0 ? 'text-green-600' : 'text-red-600';
                 const span = cellElement.querySelector('span');
                 if (span) {
                     span.classList.remove('text-green-600', 'text-red-600');
                     if (!isNaN(num)) span.classList.add(changeColor);
                 } else {
                      cellElement.classList.remove('text-green-600', 'text-red-600');
                      if (!isNaN(num)) cellElement.classList.add(changeColor);
                 }
             }
        }

        // --- Función para Conectar WebSocket ---
        function connectWebSocket() { /* ... */
            const streams = mainCryptos.map(s => `${s.toLowerCase()}@ticker`).join('/');
            const wsUrl = `${websocketUrl}/${streams}`;
            console.log(`Connecting to WebSocket: ${wsUrl}`);
            if (webSocket && webSocket.readyState === WebSocket.OPEN) { return; }
            webSocket = new WebSocket(wsUrl);
            webSocket.onopen = () => { console.log('WebSocket connection established.'); errorMessage.style.display = 'none'; };
            webSocket.onmessage = (event) => {
                 try {
                    const message = JSON.parse(event.data);
                    if (message.e === '24hrTicker') {
                        const symbol = message.s;
                        const rowData = cryptoDataMap.get(symbol);
                        if (rowData) {
                            const currentPrice = parseFloat(message.c);
                            const oldPrice = rowData.lastPrice;
                            const priceGoesUp = currentPrice >= oldPrice;
                            rowData.lastPrice = currentPrice;
                            rowData.priceChangePercent = parseFloat(message.P);
                            updateTableCell(rowData.priceCell, formatCurrency(currentPrice), true, priceGoesUp);
                            updateTableCell(rowData.changeCell, formatPercentage(message.P));
                            updateChangeColor(rowData.changeCell, message.P);
                            updateTableCell(rowData.volumeCell, formatCurrency(message.q));
                        }
                    }
                } catch (parseError) { console.error("Error parsing WebSocket message:", parseError, event.data); }
            };
            webSocket.onerror = (error) => { console.error('WebSocket Error:', error); errorMessage.innerHTML = `<p class="font-medium">¡Error de Conexión!</p><p>Problema con la conexión en tiempo real. Intentando reconectar...</p>`; errorMessage.style.display = 'block'; };
            webSocket.onclose = (event) => { console.log(`WebSocket connection closed (code: ${event.code}, reason: ${event.reason}). Attempting to reconnect...`); webSocket = null; setTimeout(connectWebSocket, 5000 + Math.random() * 1000); };
        }

        // --- Función INICIAL para Cargar Datos y Construir Tabla ---
        async function fetchInitialDataAndBuildTable() { /* ... */
              loadingIndicator.style.display = 'block';
              errorMessage.style.display = 'none';
             try {
                 console.log("Fetching initial data from:", tickerApiUrl);
                 const response = await fetch(tickerApiUrl);
                 console.log("Initial data response status:", response.status);
                 if (!response.ok) {
                     let errorText = response.statusText;
                     try { const errorBody = await response.text(); console.error("Error body from API:", errorBody); errorText = `${response.status} ${response.statusText} - ${errorBody.substring(0, 100)}`; } catch(e) { /* Ignorar */ }
                     throw new Error(`HTTP error! ${errorText}`);
                 }
                 const data = await response.json();
                 const filteredData = data.filter(ticker => mainCryptos.includes(ticker.symbol));
                 let table = cryptoTableContainer.querySelector('table');
                 if (!table) {
                     table = document.createElement('table');
                     table.className = 'min-w-full divide-y divide-gray-300';
                     table.innerHTML = `
                        <thead class="bg-gray-100">
                            <tr>
                                <th class="px-4 py-3.5 text-left text-sm font-semibold text-gray-900">Símbolo</th>
                                <th class="px-4 py-3.5 text-left text-sm font-semibold text-gray-900">Precio</th>
                                <th class="px-4 py-3.5 text-left text-sm font-semibold text-gray-900">Cambio (24h)</th>
                                <th class="px-4 py-3.5 text-left text-sm font-semibold text-gray-900">Volumen (24h)</th>
                            </tr>
                        </thead>
                        <tbody class="divide-y divide-gray-200 bg-white"></tbody>`;
                     cryptoTableContainer.appendChild(table);
                 }
                 const tbody = table.querySelector('tbody');
                 tbody.innerHTML = '';
                 cryptoDataMap.clear();
                 filteredData.sort((a, b) => mainCryptos.indexOf(a.symbol) - mainCryptos.indexOf(b.symbol));
                 filteredData.forEach(crypto => {
                     const row = tbody.insertRow();
                     row.className = 'transition-colors duration-150 ease-in-out hover:bg-blue-50 cursor-pointer';
                     row.dataset.symbol = crypto.symbol;
                     row.addEventListener('click', () => { displayChart(crypto.symbol); });
                     const cellSymbol = row.insertCell();
                     const cellPrice = row.insertCell();
                     const cellChange = row.insertCell();
                     const cellVolume = row.insertCell();
                     cellPrice.className = 'whitespace-nowrap px-4 py-4 text-sm text-gray-800 crypto-price';
                     cellChange.className = 'whitespace-nowrap px-4 py-4 text-sm crypto-change';
                     cellVolume.className = 'whitespace-nowrap px-4 py-4 text-sm text-gray-600 crypto-volume';
                     cellSymbol.className = 'whitespace-nowrap px-4 py-4 text-sm';
                     cellSymbol.innerHTML = `<div class="font-medium text-gray-900">${crypto.symbol.replace('USDT', '')}</div><div class="text-gray-500">/ USDT</div>`;
                     cellPrice.innerHTML = formatCurrency(crypto.lastPrice);
                     cellChange.innerHTML = formatPercentage(crypto.priceChangePercent);
                     updateChangeColor(cellChange, crypto.priceChangePercent);
                     cellVolume.innerHTML = formatCurrency(crypto.quoteVolume);
                     cryptoDataMap.set(crypto.symbol, { rowElement: row, priceCell: cellPrice, changeCell: cellChange, volumeCell: cellVolume, lastPrice: parseFloat(crypto.lastPrice) || 0, priceChangePercent: parseFloat(crypto.priceChangePercent) || 0 });
                 });
                  loadingIndicator.style.display = 'none';
                  if (!webSocket || webSocket.readyState === WebSocket.CLOSED) { connectWebSocket(); }
             } catch (error) {
                 console.error('Error fetching initial crypto data:', error);
                 loadingIndicator.style.display = 'none';
                 errorMessage.innerHTML = `<p class="font-medium">¡Error al Cargar Datos!</p><p>${error.message || 'Ocurrió un error desconocido.'}</p>`;
                 errorMessage.style.display = 'block';
             }
        }

        // --- Inicialización Principal ---
        // *** CAMBIO: Esperar a window.onload ***
        window.onload = () => {
            console.log("Window fully loaded (including scripts like tv.js).");

            // Verificar TradingView DESPUÉS de window.onload
             if (typeof TradingView !== 'undefined' && typeof TradingView.widget === 'function') {
                 console.log('TradingView object is available after window.onload.');
                 tradingViewReady = true; // Marcar como listo para usar
             } else {
                 console.error('TradingView object is NOT available even after window.onload. Check script tag and network.');
                 // Podrías mostrar un error persistente aquí si es crítico
                 errorMessage.innerHTML = `<p class="font-medium">¡Error Crítico!</p><p>No se pudo cargar la biblioteca de gráficos (TradingView). Los gráficos no funcionarán.</p>`;
                 errorMessage.style.display = 'block';
             }

            // Ejecutar la carga de datos y configuración de listeners
            fetchInitialDataAndBuildTable();
            closeModalBtn.addEventListener('click', closeModal);
            chartModal.addEventListener('click', (event) => { if (event.target === chartModal) { closeModal(); } });
            document.addEventListener('keydown', (event) => { if (event.key === 'Escape' && !chartModal.classList.contains('pointer-events-none')) { closeModal(); } });
        };

        // Limpiar el listener de DOMContentLoaded anterior si existía
        // (No es estrictamente necesario si se reemplaza, pero es buena práctica)
        // document.removeEventListener('DOMContentLoaded', ...) // Si hubiéramos nombrado la función

    </script>

</body>
</html>
